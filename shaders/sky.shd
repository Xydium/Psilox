VERTEX:

#version 120

void main() {
	gl_Position = projection_transform * gl_Vertex;
}

FRAGMENT:

#version 120

uniform vec4 color;
uniform float time;
uniform float threshold;

float rand(float n) {
	return fract(sin(n) * 43758.5453123);
}

float noise(float p) {
	float fl = floor(p);
	float fc = fract(p);
	return mix(rand(fl), rand(fl + 1.0), fc);
}

void main() {
	float noise = noise(gl_FragCoord.x * gl_FragCoord.y);
	vec2 coord = gl_FragCoord.xy;
	if(noise < noise(gl_FragCoord.x * (gl_FragCoord.y + 1))) {
		noise = noise(gl_FragCoord.x * (gl_FragCoord.y + 1));
		coord += vec2(0, 1);
	}
	if(noise < noise(gl_FragCoord.x * (gl_FragCoord.y - 1))) {
		noise = noise(gl_FragCoord.x * (gl_FragCoord.y - 1));
		coord += vec2(0, -1);
	}
	if(noise < noise(gl_FragCoord.y * (gl_FragCoord.x + 1))) {
		noise = noise(gl_FragCoord.y * (gl_FragCoord.x + 1));
		coord += vec2(1, 0);
	}
	if(noise < noise(gl_FragCoord.y * (gl_FragCoord.x + 1))) {
		noise = noise(gl_FragCoord.y * (gl_FragCoord.x + 1));
		coord += vec2(-1, 0);
	}
	if(noise > threshold) {
		float ntime = time * noise * rand(coord.x) * rand(coord.y);
		gl_FragColor = vec4(mod(noise * 10, 1) + -.2, mod(noise * 50, 1) + .3, mod(noise * 100, 1) + .5, sin(sin(ntime - coord.y) * cos(ntime + coord.x)));
	} else {
		gl_FragColor = color;
	}
}